--- lua 里面的 自定义 log 工具
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by Administrator.
--- DateTime: 2023/5/20 17:02
---
----- 这里的log都是调试用，release时都将无效
---- log = print
---- logf = print(format)
----


--local log

local upper = string.upper
local format = string.format
local insert = table.insert
local concat = table.concat

local disable = false
local log, logf, lazylog, lazylogf = {__tag = ""}, {__tag = ""}, {__tag = ""}, {__tag = ""}
global.log, global.logf, global.lazylog, global.lazylogf = log, logf, lazylog, lazylogf


local cache = {}
local cacheMax = 100
local logName = os.date('%Y%M%d_%H%M%S.log')
local logFile

local nullFunc = function() return true end

local iterInclude = function(t)
    return function(v)
        return itertools.include(t,v)
    end
end
local function logFlush()
    if disable or #cache == 0 then return end

    if logFile == nil then
        -- logFile = io.open(logName, "w+")
    end

    for i, t in ipairs(cache) do
        for j, v in ipairs(t) do
            t[j] = tostring(v)
        end
        cache[i] = concat(t, " ")
    end
    local s = concat(cache, "\r\n")
    if logFile then
        logFile:write(s) -- 打印到文件
        logFile:flush()
    end
    print(s) -- 打印到屏幕

    cache = {}
end

local function logPrint(...)
    -- 默认直接输出，日志多的时候可以延迟保存到文件里
    print(...)
    do return end
    insert(cache, {os.date('%H:%M:%S'), ...})

    if #cache >= cacheMax then
        logFlush()
    end
end

local filterTags = {
    battle = false,
    buff = false,
    dispel = {iterInclude({1961139,1961140})},
    overlay = {nil,nil,iterInclude({2,5,7,8})},
}

local tmp = {}
-- custom ignore by youself  格式: true--表示不显示该类型打印信息
-- tag 需要分比较细的粒度, 可以方便自由控制显示,
-- 如: log.battle.view.preload('sssss') 不要只写 log.battle('xxxxx')
-- 按层次缩进写, 表示作用域控制范围, 大的层级可以控制自己下面的层级的整体显示与否
-- 注意不要重名, 且大小写不敏感 log.battle = log.BaTTle
local ignoreTags = {
	app = true,
	alias = true,
	bind = true,
	cache = true,
	csprite = true,
	effect = true,
	guide = true,
	battleSprite = true,
	targetFinder = true,
	collectgarbage = true,
			process = true,			-- 过程段信息
			processTargets = true,		-- 过程段目标
		target = true,					-- 目标选择 [大类]
		buff = true,					-- buff [大类]
		battleView = true,				-- 战斗界面相关 [大类]
			preload = true,				-- 预加载资源内容
			notify = true,				-- 函数调用 程序用
			call = true,				-- 函数调用 程序用
	
}


for k, v in pairs(ignoreTags) do
    tmp[upper(k)] = v
end
ignoreTags = tmp

tmp = {}
for k, v in pairs(filterTags) do
    tmp[upper(k)] = v
end
filterTags = tmp

local nulltb = {}
setmetatable(nulltb, {
    __index = function(t, k)
        rawset(t, k, nulltb)
        return nulltb
    end,
    __call = function(...)
    end
})

local function logDisable()
    disable = true
    local mods = {log, logf, lazylog, lazylogf}
    for _, l in ipairs(mods) do
        for k, v in pairs(l) do
            l[k] = nil
        end
    end
    for _, l in ipairs(mods) do
        setmetatable(l, {__index = function(t, k)
            rawset(l, k, nulltb)
            return nulltb
        end})
    end
end
log.disable, logf.disable, lazylog.disable, lazylogf.disable = logDisable, logDisable, logDisable, logDisable
log.flush = logFlush

-- lazy dumps(v), help some cost-heavy string cast
local lazytb = {__lazydumps = true}
function global.lazydumps(v, f)
    if disable then return "" end
    f = f or dumps
    return setmetatable(lazytb, {__tostring = function()
        return f(v)
    end})
end

local function logIndex(setmeta)
    return function(t, k)
        local tag = upper(k)
        local tagPath = tag
        if #t.__tag > 0 then
            tagPath = format("%s %s", t.__tag, tag)
        end

        local taglog = setmeta({__tag = tagPath})
        if ignoreTags[tag] then
            taglog = nulltb
        end

        rawset(t, tag, taglog)
        rawset(taglog, "__curTag", tag)
        return taglog
    end
end


local function setLogMeta(t)
    print("local function setLogMeta(t)")
    return setmetatable(t, {
        __index = logIndex(setLogMeta),
        __call = function(t, ...)
            --setLogColor(CONSOLE_COLOR.Light_Yellow)
            logPrint(format("<%s>", t.__tag), ...)
            --setLogColor(CONSOLE_COLOR.Default)
        end
    })
end

local function setLogfMeta(t)
    print("local function setLogfMeta(t)")

    return setmetatable(t, {
        __index = logIndex(setLogfMeta),
        __call = function(t, fmt, ...)
            local filterTab = filterTags[rawget(t,"__curTag")]
            if filterTab then
                local vargs = {...}
                for k,v in pairs(filterTab) do
                    if not v(vargs[k]) then return end
                end
            end
            -- print(format("<%s> %s", t.__tag, format(fmt, unpack(vargs))))
            -- luajit支持format("%s", {}), lua不支持
            --setLogColor(CONSOLE_COLOR.Light_Yellow)
            logPrint(format("<%s> %s", t.__tag, format(fmt, ...)))
            --setLogColor(CONSOLE_COLOR.Default)
        end
    })
end

local function setLazyLogMeta(t)
    print("local function setLazyLogMeta(t)")

    return setmetatable(t, {
        __index = logIndex(setLazyLogMeta),
        __call = function(t, ...)
            local vargs = {...}
            for i, v in ipairs(vargs) do
                if type(v) == "function" then
                    vargs[i] = v()
                end
            end
            logPrint(format("<%s>", t.__tag), unpack(vargs))
        end
    })
end

local function setLazyLogfMeta(t)
    print("local function setLazyLogMeta(t)")
    return setmetatable(t, {
        __index = logIndex(setLazyLogfMeta),
        __call = function(t, fmt, ...)
            local vargs = {...}
            for i, v in ipairs(vargs) do
                if type(v) == "function" then
                    vargs[i] = v()
                end
            end
            logPrint(format("<%s> %s", t.__tag, format(fmt, unpack(vargs))))
        end
    })
end

setLogMeta(log)
setLogfMeta(logf)
setLazyLogMeta(lazylog)
setLazyLogfMeta(lazylogf)


